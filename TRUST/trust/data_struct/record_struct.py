import dataclasses as dc
from enum import Enum

from data_struct.variable_struct import Query, SectionVars, Variable


class Section(Enum):
    LBI = "LBI"
    THH = "THH"
    LEC = "LEC"
    CRA = "CRA"
    CAPS5 = "CAPS5"

    def next(self):
        sections = list(self.__class__)
        next_index = sections.index(self) + 1
        return sections[next_index] if next_index < len(sections) else None


@dc.dataclass
class LECItemMixin:
    index: int
    short_desc: str = dc.field(default_factory=str)
    long_desc: str = dc.field(default_factory=str)
    checked: bool = False


class LECItem(LECItemMixin, Enum):
    HAP = 1, "Happened to me", "it happened to you personally"
    WIT = 2, "Witnessed it", "you witnessed it happening to someone else"
    LEA = (
        3,
        "Learned about it",
        "you learned about it happening to a close family member or close friend",
    )
    JOB = (
        4,
        "Part of my job",
        "you were exposed to it as part of your job (for example, paramedic, police, military, or other first responder)",
    )
    NS = 5, "Not sure", "you're not sure if it fits"
    NA = 6, "Doesn't apply", "it doesn't apply to you"


@dc.dataclass
class Record:
    """
    Record is a data class that stores the conversation history for each turn.

    Attributes:
        section (str): The interview section name, e.g. CAPS5.
        vid (str): The variable ID/name associated with the record.
        var_idx (int): The variable index.
        qid (int): The question index.
        da_tags (list): A list of dialogue act tags.
        response (str): The response text generated by the model.
        user_input (str): The manual/simulated user input text.
    Methods:
        __post_init__(): Post-initialization method that processes the user input to remove the prompt word.

    """

    section: str = dc.field(default_factory=str)
    vid: str = dc.field(default_factory=str)
    var_idx: int = dc.field(default=0)
    qid: int | None = None
    da_tags: list | None = None
    response: str | None = None
    user_input: str | None = None
    info_enough: bool | None = None

    def __post_init__(self):
        # remove the prompt word from the user input like "User: "
        if self.user_input and ":" in self.user_input:
            self.user_input = self.user_input.split(":", 1)[1].strip()


@dc.dataclass
class Score:
    """
    A class used to represent a Score.

    Attributes:
        section (str): The interview section name, e.g. CAPS5.
        vid (str): The variable ID/name associated with the record.
        reason(str): The model generated reasoning for the score.
        answer(str) The answer associated with the score.
    """

    section: str = dc.field(default_factory=str)
    vid: str = dc.field(default_factory=str)
    reason: str = dc.field(default_factory=str)
    answer: str | int | dict = dc.field(default_factory=str)


@dc.dataclass
class UpdateSignal:
    next_turn: bool = False
    next_query: bool = False
    next_variable: bool = False
    next_section: bool = False
    end: bool = False

    def any(self) -> bool:
        return (
            self.next_turn or self.next_query or self.next_variable or self.next_section
        )

    def reset(self) -> None:
        self.next_query = False
        self.next_variable = False
        self.next_section = False


@dc.dataclass
class State:
    section: str
    section_vars: SectionVars = dc.field(repr=False)
    variable: Variable
    query: Query | None
    cur_tags: list | None = None
    response: str | None = None
    user_input: str | None = None
    info_enough: bool | None = None
    next_qid: int | None = None
    next_tags: list | None = None
    signal: UpdateSignal = dc.field(init=False)

    def __post_init__(self):
        self.signal = UpdateSignal()

    def update(
        self,
        next_section: str | None = None,
        next_section_var: SectionVars | None = None,
    ):
        if self.signal.end:
            return
        elif self.signal.next_section:
            if next_section is None or next_section_var is None:
                raise ValueError("Missing section info for section update")
            self.update_section(next_section, next_section_var)
        elif self.signal.next_variable:
            self.update_variable()
        elif self.signal.next_query:
            self.update_query()
        elif self.signal.next_turn:
            self.update_turn()

        self.reset()
        self.signal.reset()

    def update_turn(self):
        self.cur_tags = self.next_tags

    def update_query(self):
        if not self.next_qid:
            raise ValueError("next_qid is None")
        self.query = self.variable.get_query_by_qid(self.next_qid)

    def update_variable(self):
        self.variable = self.section_vars[self.variable.var_idx + 1]
        if self.next_qid:
            self.update_query()
        else:
            self.query = None

    def update_section(self, section: str, section_vars: SectionVars):
        self.section = section
        self.section_vars = section_vars
        self.variable = section_vars[0]
        self.query = None

    def reset(self):
        self.response = None
        self.user_input = None
        self.cur_tags = self.next_tags
        self.info_enough = False
        self.next_qid = None
        self.next_tags = None

    def to_assess(self) -> bool:
        if self.signal.next_variable or self.signal.next_section:
            return True
        return False

    def to_record(self) -> Record:
        """
        Convert the state to a Record object.

        Returns:
            Record: A Record object representing the current state.
        """

        return Record(
            section=self.section,
            vid=self.variable.vid,
            var_idx=self.variable.var_idx,
            qid=self.query.qid if self.query else None,
            da_tags=self.cur_tags if self.variable else None,
            response=self.response,
            user_input=self.user_input,
            info_enough=self.info_enough,
        )

    def to_turn(self) -> tuple | None:
        if self.response or self.user_input:
            return (self.response, self.user_input)
        return None

    @classmethod
    def from_tracker(cls, last_state: dict, section_vars: SectionVars) -> "State":
        """
        Create a State object from a Record object.

        Parameters:
            record (Record): The Record object to convert.
            section_vars (SectionVars): The SectionVars object containing the variables for the section.

        Returns:
            State: A State object representing the Record.
        """
        variable = section_vars[last_state["var_idx"]]
        query = (
            variable.get_query_by_qid(last_state["qid"]) if last_state["qid"] else None
        )
        return cls(
            section=last_state["section"],
            section_vars=section_vars,
            variable=variable,
            query=query,
            cur_tags=last_state["da_tags"],
            response=last_state["response"],
            user_input=last_state["user_input"],
            info_enough=last_state["info_enough"],
            next_qid=last_state.get("next_qid", None),
            next_tags=last_state.get("next_tags", None),
        )


if __name__ == "__main__":
    # section = Section.CAPS5
    # print(section.next())  # Output: Section.LEC
    for item in LECItem:
        print(f"{item.index}: {item.short_desc} - {item.long_desc}")
